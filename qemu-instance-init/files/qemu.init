#!/bin/sh /etc/rc.common

# shellcheck shell=busybox

USE_PROCD=1
START=99
STOP=1

# XXX TODO: detect arch
PROG=/usr/bin/qemu-system-x86_64

# XXX may be optional
extra_command "backup" "run proxmox-backup-client (all or one instance)"

_log() {
	local level="$1"
	shift
	local instance="$1"
	shift
	logger -s -t "qemu.$instance" -p "daemon.$level" "$level:" "$@"
}

log_error() {
	_log ERROR "$@"
}
log_warn() {
	_log WARN "$@"
}
log_info() {
	_log INFO "$@"
}
log_debug() {
	_log DEBUG "$@"
}

list_append_args() {
	# NOTE: filter empty args
	[ -n "$1" ] && procd_append_param command "$1"
}

start_instance() {
	local instance="$1" enabled

	config_get_bool enabled "$instance" enabled 1
	[ "$enabled" = 1 ] || return

	local vcpus ram cpu_type uuid vnc qmp_port term_timeout
	local root_disk root_disk_type uefi_code uefi_vars
	local net0_mac net0_bridge
	local guest_agent guest_agent_socket
	config_get vcpus "$instance" vcpus 1
	config_get ram "$instance" ram '512M'
	config_get cpu_type "$instance" cpu_type 'host'
	config_get uuid "$instance" uuid
	config_get vnc "$instance" vnc 'none'
	config_get qmp_port "$instance" qmp_port 4444
	config_get term_timeout "$instance" term_timeout 300
	config_get root_disk "$instance" root_disk
	config_get root_disk_type "$instance" root_disk_type 'qcow2'
	config_get net0_mac "$instance" net0_mac
	config_get net0_bridge "$instance" net0_bridge 'br-lan'
	config_get uefi_code "$instance" uefi_code
	config_get uefi_vars "$instance" uefi_vars
	config_get_bool guest_agent "$instance" guest_agent 0
	config_get guest_agent_socket "$instance" guest_agent_socket "/var/run/qemu.$instance.qga.sock"

	if [ -z "$uuid" ]; then
		uuid=$(uuidgen --md5 --namespace 5d762436-dc3c-45c4-9896-d078210eec5a --name "$instance")
		log_info "$instance" "uuid is not set. Generated UUID5 from instance name: $uuid"
	fi

	procd_open_instance "$instance"
	procd_set_param command "$PROG" -enable-kvm -cpu "$cpu_type" \
		-smp "$vcpus" -m "$ram" -uuid "$uuid"

	if [ -n "$uefi_code" ]; then
		if [ ! -e "$uefi_code" ]; then
			log_error "$instance" "uefi code: $root_disk: does not exist"
			procd_set_param error "uefi code: $root_disk: does not exist"
		fi

		procd_append_param command -drive "if=pflash,file=$uefi_code,format=raw,readonly=on"
	fi
	if [ -n "$uefi_vars" ]; then
		if [ ! -e "$uefi_vars" ]; then
			log_error "$instance" "uefi vars: $root_disk: does not exist"
			procd_set_param error "uefi vars: $root_disk: does not exist"
		fi

		procd_append_param command -drive "if=pflash,file=$uefi_vars,format=raw"
	fi

	if [ ! -e "$root_disk" ]; then
		log_error "$instance" "root disk: $root_disk: does not exist"
		procd_set_param error "root disk: $root_disk: does not exist"
	else
		if [ "$root_disk_type" = "qemu2" ]; then
			procd_append_param command -device virtio-scsi-pci,id=scsi
			procd_append_param command -drive "id=root-img,format=qcow2,file=$root_disk,if=virtio"
		fi
		if [ "$root_disk_type" = "lvm" ]; then
			procd_append_param command -device virtio-scsi-pci,id=scsi
			procd_append_param command -drive "id=root-img,format=raw,file=$root_disk,if=virtio,cache.direct=on"
		fi
	fi

	if [ -n "$net0_mac" ]; then
		procd_append_param command -device "virtio-net-pci,mac=$net0_mac,netdev=net0"
		procd_append_param command -netdev "bridge,br=$net0_bridge,id=net0"
	fi

	[ -n "$vnc" ] && procd_append_param command -vnc "$vnc"
	procd_append_param command -qmp "tcp:127.0.0.1:$qmp_port,server,nowait"

	if [ "$guest_agent" = 1 ]; then
		procd_append_param command -chardev "socket,path=$guest_agent_socket,server,nowait,id=qga0"
		procd_append_param command -device virtio-serial
		procd_append_param command -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0
	fi

	config_list_foreach "$instance" extra_args list_append_args

	procd_set_param stdout 1
	procd_set_param stderr 1
	procd_set_param respawn
	procd_set_param term_timeout "$term_timeout"
	procd_set_param pidfile "/var/run/qemu.$instance.pid"

	procd_close_instance
}

_stop_instance_task(){
	local instance="$1" qmp_port="$2" term_timeout="$3" qemu_pid="$4"

	if [ ! -e "/proc/$qemu_pid" ]; then
		log_info "$instance" "VM process already absent"
		return
	fi

	log_info "$instance" "sending 'system_powerdown' to VM with PID $qemu_pid."
	nc 127.0.0.1 "$qmp_port" <<-QMP
	{ "execute": "qmp_capabilities" }
	{ "execute": "system_powerdown" }
	QMP

	log_info "$instance" "waiting VM to shutdown."
	local elapsed=0
	while [ "$elapsed" -lt "$term_timeout" ]; do
		if [ ! -e "/proc/$qemu_pid" ]; then
			log_info "$instance" "VM process finished. elapsed: $elapsed"
			return
		fi

		log_debug "$instance" "PID $qemu_pid present. elapsed: $elapsed"

		sleep 1s
		elapsed=$((elapsed + 1))
	done

	log_error "$instance" "graceful VM termination timeout reached, giving up to procd"
}

stop_instance() {
	local instance="$1"

	config_get_bool enabled "$instance" enabled 1
	[ "$enabled" = 1 ] || return

	local qmp_port term_timeout qemu_pid
	config_get qmp_port "$instance" qmp_port 4444
	config_get term_timeout "$instance" term_timeout 300

	local pidfile="/var/run/qemu.$instance.pid"
	if [ ! -e "$pidfile" ]; then
		log_warn "$instance" "pid file: $pidfile: does not exist. Is the instance already stopped?"
		return
	fi

	qemu_pid=$(cat "$pidfile")
	_stop_instance_task "$instance" "$qmp_port" "$term_timeout" "$qemu_pid" &
}

backup_instance() {
	local instance="$1" backup hostname

	config_get_bool backup "$instance" backup 0
	[ "$backup" = 1 ] || return

	hostname=$(uname -n)

	local qmp_port backup_server backup_id
	config_get qmp_port "$instance" qmp_port 4444
	config_get root_disk "$instance" root_disk
	config_get uefi_code "$instance" uefi_code
	config_get uefi_vars "$instance" uefi_vars
	config_get backup_server "$instance" backup_server
	config_get backup_id "$instance" backup_id "${hostname}-vm-${instance}"

	# load backup env vars
	config_get PBS_REPOSITORY "$backup_server" repository
	config_get PBS_PASSWORD "$backup_server" password
	config_get PBS_FINGERPRINT "$backup_server" fingerprint
	config_get PBS_NAMESPACE "$backup_server" namespace
	# see https://pbs.proxmox.com/docs-1/backup-client.html#environment-variables
	export PBS_REPOSITORY PBS_PASSWORD PBS_FINGERPRINT

	# load notify url
	local gotify_url gotify_app_token
	config_get gotify_url "$backup_server" gotify_url
	config_get gotify_app_token "$backup_server" gotify_app_token

	if [ -z "$PBS_REPOSITORY" ] || [ -z "$PBS_PASSWORD" ] || [ -z "$PBS_FINGERPRINT" ]; then
		log_error "$instance" "pbs client unconfigured: $backup_server"
		return
	fi
	if [ ! -e "$root_disk" ]; then
		log_error "$instance" "root disk: $root_disk: not exist"
		return
	fi

	log_info "$instance" "begin backup"

	local pidfile="/var/run/qemu.$instance.pid"
	if [ -e "$pidfile" ]; then
		local qemu_pid
		qemu_pid=$(cat "$pidfile")

		log_info "$instance" "sending 'block-flush' to VM with PID $qemu_pid."
		nc 127.0.0.1 "$qmp_port" <<-QMP
		{ "execute": "qmp_capabilities" }
		{ "execute": "block-flush", "arguments": { "device": "drive0" } }
		QMP

		# NOTE: ideally should make a lvm snapshot, then backup.
		#       but porting all logic of vzdump is too much work...
	fi

	local backup_log="/tmp/pbs-backup.$instance.log"

	# XXX need to have safe globbing
	local pbs_args=""
	if [ -n "$PBS_NAMESPACE" ]; then
		pbs_args="$pbs_args --ns $PBS_NAMESPACE"
	fi

	# TODO: support multiple drives
	pbs_args="$pbs_args disk0.img:$root_disk"

	if [ -n "$uefi_code" ]; then
		pbs_args="$pbs_args pflash0_code.img:$uefi_code"
	fi
	if [ -n "$uefi_vars" ]; then
		pbs_args="$pbs_args pflash0_efivars.img:$uefi_vars"
	fi

	set -o pipefail

	# shellcheck disable=SC2086
	proxmox-backup-client backup --backup-type vm --backup-id "$backup_id" $pbs_args 2>&1 | tee "$backup_log"
	local rc=$?

	if [ "$rc" -ne 0 ]; then
		log_error "$instance" "backup failed: rc: $rc"
		gotify_stat="failed rc=$rc"
		gotify_prio=9
	else
		log_info "$instance" "backup successful"
		gotify_stat="successful"
		gotify_prio=1
	fi

	if [ -n "$gotify_url" ]; then
		curl "$gotify_url/message" -H "X-Gotify-Key: $gotify_app_token" -X POST \
			-F "title=$hostname $backup_id backup: $gotify_stat" \
			-F "$(printf 'message=```\n%s\n```\n' "$(cat $backup_log)")" \
			-F "priority=$gotify_prio" \
			-F 'extras={"client::display": {"contentType": "text/markdown"}}'
		rc2=$?
		if [ "$rc2" -ne 0 ]; then
			log_error "$instance" "failed to notify gotify: rc: $rc2"
		else
			log_info "$instance" "gotify notified successfully"
		fi
	fi

	log_info "$instance" "end backup"
}

start_service() {
	local instance="$1"

	config_load qemu
	if [ -z "$instance" ]; then
		config_foreach start_instance instance
	else
		start_instance "$instance"
	fi
}

stop_service() {
	local instance="$1"

	config_load qemu
	if [ -z "$instance" ]; then
		config_foreach stop_instance instance
	else
		stop_instance "$instance"
	fi

	wait
}

backup() {
	local instance="$1"

	config_load qemu
	if [ -z "$instance" ]; then
		config_foreach backup_instance instance
	else
		backup_instance "$instance"
	fi
}
